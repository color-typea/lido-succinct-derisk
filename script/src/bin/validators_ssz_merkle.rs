//! An end-to-end example of using the SP1 SDK to generate a proof of a program that can be verified
//! on-chain.
//!
//! You can run this script using the following command:
//! ```shell
//! RUST_LOG=info cargo run --package fibonacci-script --bin prove --release
//! ```

use alloy_sol_types::{sol, SolType};
use clap::Parser;
use hex_literal::hex;
use serde::{Deserialize, Serialize};
use sp1_sdk::{ProverClient, SP1CompressedProof, SP1ProvingKey, SP1Stdin, SP1VerifyingKey};
use std::collections::HashMap;

use lido_derisk_lib::hashing::sha256;
use lido_derisk_lib::ssz::validator::Validator;
use lido_derisk_lib::utils::{clone_into_array, pad_zeroes};
use std::path::PathBuf;

use log::{debug, info, warn};
use sp1_sdk::HashableKey;

/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.
///
/// This file is generated by running `cargo prove build` inside the `program` directory.
pub const ELF: &[u8] = include_bytes!("../../../program/elf/riscv32im-succinct-zkvm-elf");

type HashElement = [u8; 32];
type Proof = sp1_sdk::SP1PlonkBn254Proof;
// type Proof = sp1_sdk::SP1CompressedProof;

/// The arguments for the prove command.
#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct ProveArgs {
    #[clap(long, default_value = "10")]
    size: u32,
}

/// The public values encoded as a tuple that can be easily deserialized inside Solidity.
type PublicValuesTuple = sol! {
    tuple(bytes32,)
};

/// A fixture that can be used to test the verification of SP1 zkVM proofs inside Solidity.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
struct SP1MerkleProofFixture {
    merkle_root: String,
    public_values: String,
    proof: String,
    vkey: String,
}

fn merkle_hashes_map() -> HashMap<u32, HashElement> {
    return HashMap::from([
        (
            2,
            hex!("45f756e30f2c2ee102d90fbff583f48264049f1ab19d9a7653434170010f8d5e"),
        ),
        (
            3,
            hex!("9e98bcd4169ffec383f2741f98dcb41e1b58fae813aa813e002dd7520ae10fac"),
        ),
        (
            4,
            hex!("b8d9b2a2293a5215b31ed0ad22c59a7d2cbaf31a349210eeef3fe3ce23f06f70"),
        ),
        (
            5,
            hex!("7a7f5aa5d7b5b25383cc28a191850ae7ef671a4497f6038c09e271f5876f8c2b"),
        ),
        (
            6,
            hex!("af4fdb0ecc01ebb4f0edd8f1f28215c496604c73ec4d2958b03017f99c9cd4c8"),
        ),
        (
            7,
            hex!("77dbfdeba0d6f95a91313518580bc150f1a85c0b63e845c5a66b143e35e0eb94"),
        ),
        (
            8,
            hex!("b8ec486c0f8452c72ed2c9978f01ec52c9d3e625bce4c3f1ff32e67935a92043"),
        ),
        (
            9,
            hex!("b5233230fca50f4e78c8381e436d1ec5db37800d31b4cea8c698a972929801ef"),
        ),
        (
            10,
            hex!("3c8de9167c587c7bba37bfefba8bcbaf6f2ed5f05fd6b92f4211976758d75cea"),
        ),
        (
            11,
            hex!("add5bb505ddb06e62e89a3b8f66d955ff1640e19e982d15324833d73bfc6150b"),
        ),
        (
            12,
            hex!("487cb7e734bfe1f41be7819d36f174970556dcfbd9f3f68894899d541493c5f1"),
        ),
        (
            13,
            hex!("1afba78655f712c1407cc54cf00a209fd4d97fb12397700e5d16a51c9515d469"),
        ),
        (
            14,
            hex!("b8040e38d0b91311881557728f16bd0c6875836f76fd786c3776e29d3d52c81e"),
        ),
        (
            15,
            hex!("8b20f5911d8184f07f506759dd060b2885f2027f4f32a0cc5c0be35312f252bd"),
        ),
        (
            16,
            hex!("27a2f5ca48a7947f27e8dbdba1083b5239665f7115e355e11903ff3bb18c8a95"),
        ),
        (
            17,
            hex!("9bd48522b062a0799fc4afe9766398600d8ef25f3f59ee449abc02c9014e75f8"),
        ),
        (
            18,
            hex!("8fa876393f795b25ff94a7f99b949e1d5b5049abd5e420ce91896cf029cafa62"),
        ),
        (
            19,
            hex!("bf01aa28f7d49d1ab69c887646b93fa5d4bb8bd8407ef77b660f45776b5f5a26"),
        ),
        (
            20,
            hex!("2ef2d2fa41f407897ce63bba7c3964659b078c377a3ddb9a4981587960059876"),
        ),
        (
            21,
            hex!("1c932c0ee2f0693e11aac1eefd444007f32f29a199104f237a3e8870ddc84196"),
        ),
        (
            22,
            hex!("7810a7730c5d78e27139220eb25bdb844c9f27db9364c9ba66ae1fa4f77bb4f3"),
        ),
    ]);
}

const FAR_FUTURE_EPOCH: u64 = u64::MAX;

fn hash_pubkey(pubkey: [u8; 48]) -> HashElement {
    let pubkey_low: HashElement = clone_into_array(&pubkey[0..32]);
    let pubkey_high: [u8; 16] = clone_into_array(&pubkey[32..48]);
    sha256::hash(&pubkey_low, &pad_zeroes(&pubkey_high))
}

const WITHDRAWAL_CREDS_LIDO: HashElement =
    hex!("010000000000000000000000b9d7934878b5fb9610b3fe8a5e441e8fad7e293f");
const WITHDRAWAL_CREDS_OTHER: HashElement =
    hex!("0101010101010101010101010101010101010101010101010101010101010101");

fn make_validator(index: u64, is_lido: bool) -> Validator {
    let withdrawal_credentials = if is_lido {
        WITHDRAWAL_CREDS_LIDO
    } else {
        WITHDRAWAL_CREDS_OTHER
    };
    let pubkey: [u8; 48] = pad_zeroes(&index.to_le_bytes());
    // let low: &[u8; 32] = unsafe { &*(pubkey[0..32].as_ptr() as *const [u8; 32]) };
    // let high: &[u8; 32] = unsafe { &*(pubkey[32..64].as_ptr() as *const [u8; 32]) };
    let activation_eligibility_epoch = index / 10;

    Validator {
        // pubkey: hash(low, high).into(),
        pubkey: hash_pubkey(pubkey).into(),
        withdrawal_credentials: withdrawal_credentials.into(),
        effective_balance: 32 * 10_u64.pow(9),
        slashed: false,
        activation_eligibility_epoch: activation_eligibility_epoch,
        activation_epoch: activation_eligibility_epoch + 1,
        exit_epoch: FAR_FUTURE_EPOCH,
        withdrawable_epoch: activation_eligibility_epoch + 2,
    }
}

fn make_validators(size: u32) -> Vec<Validator> {
    let count = 2_u64.pow(size);
    let lido = 2_u64.pow(size - 1);
    // balances = [i * (10 ** 9) for i in range(count)]

    let validators: Vec<Validator> = (0..count)
        .map(|index| make_validator(index, index < lido))
        .collect();

    validators
}

fn write_fixture(expected_merkle_root: &HashElement, vk: &SP1VerifyingKey, proof: &Proof) {
    // Create the testing fixture so we can test things end-ot-end.
    let fixture = SP1MerkleProofFixture {
        merkle_root: hex::encode(*expected_merkle_root),
        vkey: vk.bytes32().to_string(),
        public_values: proof.public_values.bytes().to_string(),
        proof: proof.bytes().to_string(),
    };

    // The verification key is used to verify that the proof corresponds to the execution of the
    // program on the given input.
    //
    // Note that the verification key stays the same regardless of the input.
    println!("Verification Key: {}", fixture.vkey);

    // The public values are the values whicha are publically commited to by the zkVM.
    //
    // If you need to expose the inputs or outputs of your program, you should commit them in
    // the public values.
    println!("Public Values: {}", fixture.public_values);

    // The proof proves to the verifier that the program was executed with some inputs that led to
    // the give public values.
    println!("Proof Bytes: {}", fixture.proof);

    // Save the fixture to a file.
    let fixture_path = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("../contracts/src/fixtures");
    std::fs::create_dir_all(&fixture_path).expect("failed to create fixture path");
    std::fs::write(
        fixture_path.join("fixture.json"),
        serde_json::to_string_pretty(&fixture).unwrap(),
    )
    .expect("failed to write fixture");
}

fn main() {
    // Setup the logger.
    sp1_sdk::utils::setup_logger();

    // Parse the command line arguments.
    let args = ProveArgs::parse();

    // Setup the prover client.
    let client = ProverClient::new();

    // Setup the program.
    let (pk, vk) = client.setup(ELF);

    let size: u32 = args.size;

    let input: Vec<Validator> = make_validators(size);
    let expected_hashes = merkle_hashes_map();
    let expected_merkle_root: &HashElement = expected_hashes.get(&size).expect("unsupported size");

    // Generate the proof.
    let mut stdin: SP1Stdin = SP1Stdin::new();

    // debug!("Input {:?}", input);

    stdin.write(&input);
    stdin.write(&expected_merkle_root);

    let proof = client
        .prove_plonk(&pk, stdin)
        // .prove_compressed(&pk, stdin)
        .expect("failed to generate proof");

    // Read output.
    let bytes = proof.public_values.as_slice();
    let public_values = PublicValuesTuple::abi_decode(bytes, false).unwrap();
    let (merkle_root,) = public_values;

    debug!("Expected merkle root: {:02X?}", expected_merkle_root);
    debug!("Actual   merkle root: {:?}", merkle_root);

    assert_eq!(merkle_root, *expected_merkle_root);
    println!("Proof created");

    write_fixture(expected_merkle_root, &vk, &proof);

    // Verify proof
    client
        .verify_plonk(&proof, &vk)
        // .verify_compressed(&proof, &vk)
        .expect("verification failed");
    println!("Verified successfully");
}

// SP1_PROVER=network SP1_PRIVATE_KEY=0x9c2275f571686c4cb04f040e81ffcf45c0a651b1698cf48ddcfb132e5b140001 RUST_LOG=debug cargo run --bin validators_ssz_merkle --release -- --size 6
